apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'spring-boot'

apply from: 'source.gradle'

task setVersion {
  description  'Defines the version from the state in git'
  dependsOn 'taGit'
  doFirst {
    version = getVersionName()
    println 'Version: ' + version
    // create a version.env file for Jenkins
    def envFile = new File('version.env')
    envFile.write 'VERSION=' + version +'\n'
  }
}

group = 'org.apache.mesos.kibana'

/*
 * When you build a new release
 * this task tags the repository
 *
 * gradle build -PtagRelease
 *
 */

task taGit {
  description 'Create an annotated tag on the current sha1 using the content of the file tag.txt'
  doFirst {
    // ToDo: Should really use release.properties for version and message
    def tagFile = new File('tag.txt')
    def tagLines = tagFile.readLines()
    assert 1 <= tagLines.size()
    println 'Using: git tag -a -F ' + tagFile + ' ' + tagLines[0]
    exec {
      commandLine 'git', 'tag', '-a', '-F', tagFile, tagLines[0]
    }
  }

}
taGit.onlyIf { project.hasProperty('tagRelease') }

task deploy {


  doFirst{
    apply from: 'deploy.properties'

    // ToDo: Complete for SSH set ups
    // ToDo: Allow image names and detect IP in docker set ups
    // ToDo: unless elasticsearch have data add shaspear set
    // ToDo: add a generic "error handler" for the exec calls
    def baseCmd = []
    def dockerSys = 0
    def mesosMaster

    def stdout
    def stderr

    // first docker image or system w SSH
    if (project.hasProperty('deploySSH') & deploySSH.length() > 0) {
      println 'SSH: ' + deploySSH
      baseCmd = ['ssh', deploySSH, '-c']
    } else if (project.hasProperty('deployDocker') & deployDocker.length() > 0) {
      println 'Docker: ' + deployDocker
      dockerSys = 1
      baseCmd = ['docker', 'exec', deployDocker]
    } else {
      System.err.println 'Error:\n   One of the options must be defined'
      System.err.println '     deploySSH or deployDocker\n   in the deploy.properties file'
      System.exit(1)
    }
    // second direct master address or via zookeepr
    if (project.hasProperty('deployMaster') & deployMaster.length() >0 ) {
      mesosMaster=deployMaster
    } else if (project.hasProperty('deployZK') & deployZK.length() > 0) {
      mesosMaster=deployZK
    } else {
      System.err.println 'Error:\n   One of the options must be defined'
      System.err.println '     deployMaster or deployZK\n   in the deploy.properties file'
      System.exit(2)
    }
    println 'Master: ' + mesosMaster

    // finally the elastic search instances
    def esString = ''
    if (project.hasProperty('deployES1') & deployES1.length() >0) {
      esString = esString + ' ' + deployES1
    }
    if (project.hasProperty('deployES2') & deployES2.length() >0) {
      esString = esString + ' ' + deployES2
    }
    if (project.hasProperty('deployES3') & deployES3.length() >0) {
      esString = esString + ' ' + deployES3
    }
    if (project.hasProperty('deployES4') & deployES4.length() >0) {
      esString = esString + ' ' + deployES4
    }
    if (project.hasProperty('deployES5') & deployES5.length() >0) {
      esString = esString + ' ' + deployES5
    }
    if (esString.length() > 0) {
      println 'ES: ' + esString
    } else {
      System.err.println 'Error:\n   One elastic search instance must be defined'
      System.err.println '     deployESn\n   in the deploy.properties file'
      System.exit(2)
    }
    // which curl
    println 'Base:' + baseCmd

    (stdout, stderr) = runExec(baseCmd + ['which', 'curl'])
    if (stderr.length() ==0) {
      if (stdout.length() ==0) {
        if (dockerSys == 1) {
          //0 install curl
          runExec(baseCmd + ['apt-get', 'update'])
          runExec(baseCmd + ['apt-get', 'install', 'curl'])
        } else {
          println 'Please install curl on the mesos-master '
          System.exit(1)
        }
      }
    } else {
      println 'Error: ' + stderr
      System.exit(1)
    }
    // 1 curl down latest kibana  to kibana.jar
    // ToDo get latest kibana version from the json api of jenkins
    def latestJar = 'http://code.praqma.net/ci/view/Mesos_Kibana/job/mesos-kibana_release/lastSuccessfulBuild/artifact/build/libs/kibana-0.0.1.jar'
    (stdout, stderr) = runExec(baseCmd + ['curl', '-sf', latestJar, '-O'])

    if (dockerSys==1) {
      (stdout, stderr) = runExec(['docker', 'exec', '-d', deployDocker, 'java', '-jar', 'kibana-0.0.1.jar', deployMaster, esString])
    }
  }
}

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.2.5.RELEASE")
    }
}

repositories {
    mavenCentral()
}

dependencies {
    compile(

            [group: 'commons-cli', name: 'commons-cli', version: '1.3.1'],
            [group: 'org.apache.mesos', name: 'mesos', version: '0.22.1'],
            [group: 'org.slf4j', name: 'slf4j-api', version: '1.7.7'],
            [group: 'org.springframework.boot', name: 'spring-boot-starter-web', version: '1.2.5.RELEASE'])
    testCompile(
            [group: 'org.mockito', name: 'mockito-all', version: '1.10.19'],
            [group: 'junit', name: 'junit', version: '4.10'])
}

jar {
    dependsOn 'setVersion'
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } } // Include dependencies
    manifest {
        attributes 'Main-Class': 'org.apache.mesos.kibana.KibanaFramework'
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.3'
}
